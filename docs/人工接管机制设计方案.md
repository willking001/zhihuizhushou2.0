# 人工接管机制设计方案

## 1. 概述

本文档详细描述了智慧助手2.0系统中人工接管机制的设计方案，包括触发条件、预警动作、技术实现和用户体验优化等方面。该机制旨在确保在自动回复无法满足用户需求时，能够及时、准确地转接人工客服，提供更好的用户体验。

## 2. 触发条件细化

### 2.1 关键词触发

#### 2.1.1 直接触发词（立即转人工）
- **人工服务类**："要人工"、"转人工"、"人工客服"、"客服"、"人工服务"
- **不满意类**："不满意"、"不行"、"没用"、"不对"、"错误"
- **投诉类**："投诉"、"举报"、"问题"、"抱怨"、"意见"
- **升级类**："经理"、"领导"、"负责人"、"主管"、"老板"

#### 2.1.2 情感触发词（评分后决定）
- **轻度负面**（+1分）："烦"、"急"、"慢"、"等"
- **中度负面**（+2分）："气"、"怒"、"烦躁"、"着急"
- **重度负面**（+3分）："垃圾"、"废物"、"傻"、"笨"
- **求助情感**（+1分）："帮帮我"、"求求你"、"拜托"、"救命"

#### 2.1.3 累计触发机制
- **5分钟内累计负面情感≥3分**：自动转人工
- **单次强负面≥3分**：立即转人工
- **连续3次负面词汇**：自动转人工

### 2.2 重复询问检测

#### 2.2.1 检测算法
- **文本相似度检测**：相似度>80%且时间间隔<10分钟
- **语义相似检测**：同一用户3次相似问题（语义相似度>60%）
- **关键词重复**：核心关键词连续出现3次以上

#### 2.2.2 触发条件
- **2次完全重复**：发送提示"我来为您转接人工客服"
- **3次重复**：自动转人工，无需确认
- **跨时段重复**（>1小时）：重新计数
- **不同表达同一问题**：智能识别后累计计算

### 2.3 情感分析细化

#### 2.3.1 情感评分标准
- **正面情感**：0.7-1.0（继续自动回复）
- **中性情感**：0.3-0.7（正常处理）
- **负面情感**：0.1-0.3（警告状态，记录+1）
- **强负面**：0.0-0.1（立即转人工）

#### 2.3.2 上下文分析
- **连续负面**：连续3条消息负面情感>0.3时转人工
- **情感波动**：从正面突然转负面时重点关注
- **语气强化**：配合语气词分析（"！！！"、"？？？"、"...")增加权重
- **时间因素**：深夜或节假日降低转人工阈值

## 3. 预警动作细化

### 3.1 推送通知分级

#### 3.1.1 Level 1 - 普通提醒
- **触发条件**：负面关键词、重复询问、轻度情感波动
- **推送内容**："[群名]有用户需要关注，请及时处理"
- **推送方式**：App通知、微信工作消息
- **响应时间**：5分钟内
- **处理人员**：当班客服

#### 3.1.2 Level 2 - 紧急提醒
- **触发条件**：强负面情感、投诉类关键词、连续重复
- **推送内容**："[群名]紧急情况！用户情绪激动，请立即处理"
- **推送方式**：电话+短信+App强提醒
- **响应时间**：1分钟内
- **处理人员**：客户经理

#### 3.1.3 Level 3 - 严重告警
- **触发条件**：连续负面反馈、威胁性言论、升级要求
- **推送内容**："[群名]严重投诉！请主管立即介入处理"
- **推送方式**：多级推送（客户经理+主管+值班领导）
- **响应时间**：立即
- **处理人员**：部门主管

### 3.2 自动暂停机制

#### 3.2.1 暂停策略
- **单群暂停**：仅暂停触发群组的自动回复
- **用户暂停**：暂停该用户在所有群组的自动回复
- **关键词暂停**：暂停特定关键词的自动触发
- **时段暂停**：特定时间段内暂停自动回复

#### 3.2.2 暂停时长
- **普通情况**：30分钟自动恢复
- **紧急情况**：需人工确认后恢复
- **严重情况**：24小时内禁止自动回复
- **投诉情况**：需主管审批后恢复

#### 3.2.3 暂停提示
- **对用户**："已为您安排专人处理，请稍候..."
- **对群组**："[机器人已暂停，人工客服接管中]"
- **对管理员**："群组[XXX]自动回复已暂停，原因：[XXX]"

### 3.3 标记处理流程

#### 3.3.1 标记类型
- **PENDING_MANUAL**：等待人工处理
- **URGENT_MANUAL**：紧急人工处理
- **COMPLAINT_MANUAL**：投诉类人工处理
- **ESCALATED**：已升级处理
- **VIP_MANUAL**：VIP用户人工处理

#### 3.3.2 处理流程
1. **自动标记** → 系统检测到触发条件
2. **推送通知** → 按级别推送给相应人员
3. **暂停自动回复** → 防止进一步自动回复
4. **等待人工接管** → 显示等待提示
5. **人工处理** → 客服人员介入处理
6. **问题解决** → 处理完成，用户满意
7. **恢复自动回复** → 恢复正常自动回复
8. **记录归档** → 记录处理过程和结果

#### 3.3.3 超时处理
- **5分钟无响应**：升级推送给上级
- **15分钟无响应**：推送给部门主管
- **30分钟无响应**：推送给值班领导
- **1小时无响应**：自动升级为严重事件

## 4. 技术实现方案

### 4.1 数据库设计

#### 4.1.1 人工接管记录表
```sql
CREATE TABLE manual_takeover_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    group_id VARCHAR(100) NOT NULL COMMENT '群组ID',
    user_id VARCHAR(100) NOT NULL COMMENT '用户ID',
    trigger_type ENUM('KEYWORD', 'REPEAT', 'EMOTION', 'MANUAL') NOT NULL COMMENT '触发类型',
    trigger_content TEXT COMMENT '触发内容',
    emotion_score DECIMAL(3,2) COMMENT '情感分数',
    urgency_level ENUM('LOW', 'MEDIUM', 'HIGH', 'CRITICAL') NOT NULL COMMENT '紧急程度',
    status ENUM('PENDING', 'PROCESSING', 'RESOLVED', 'ESCALATED') NOT NULL COMMENT '处理状态',
    assigned_to VARCHAR(100) COMMENT '分配给',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    resolved_at TIMESTAMP NULL COMMENT '解决时间',
    resolution_note TEXT COMMENT '解决备注',
    INDEX idx_group_user (group_id, user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);
```

#### 4.1.2 群组状态表
```sql
CREATE TABLE group_status (
    group_id VARCHAR(100) PRIMARY KEY COMMENT '群组ID',
    auto_reply_enabled BOOLEAN DEFAULT TRUE COMMENT '自动回复启用状态',
    manual_mode_until TIMESTAMP NULL COMMENT '人工模式截止时间',
    last_trigger_time TIMESTAMP NULL COMMENT '最后触发时间',
    trigger_count INT DEFAULT 0 COMMENT '触发次数',
    assigned_manager VARCHAR(100) COMMENT '分配的客户经理',
    pause_reason VARCHAR(200) COMMENT '暂停原因',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

#### 4.1.3 用户情感历史表
```sql
CREATE TABLE user_emotion_history (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id VARCHAR(100) NOT NULL COMMENT '用户ID',
    group_id VARCHAR(100) NOT NULL COMMENT '群组ID',
    message_content TEXT NOT NULL COMMENT '消息内容',
    emotion_score DECIMAL(3,2) NOT NULL COMMENT '情感分数',
    emotion_type ENUM('POSITIVE', 'NEUTRAL', 'NEGATIVE', 'VERY_NEGATIVE') NOT NULL COMMENT '情感类型',
    keywords JSON COMMENT '触发的关键词',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_user_group (user_id, group_id),
    INDEX idx_created_at (created_at)
);
```

### 4.2 核心算法实现

#### 4.2.1 人工接管触发器
```python
class ManualTakeoverTrigger:
    def __init__(self):
        self.emotion_threshold = 0.3
        self.repeat_threshold = 3
        self.negative_keywords = ["不满意", "要人工", "投诉", "举报"]
        self.urgent_keywords = ["垃圾", "废物", "傻", "笨"]
        self.service_keywords = ["人工", "客服", "经理", "领导"]
    
    def should_trigger_manual(self, message, user_history, group_context):
        """
        判断是否应该触发人工接管
        
        Args:
            message: 当前消息
            user_history: 用户历史消息
            group_context: 群组上下文
        
        Returns:
            tuple: (是否触发, 触发原因列表, 紧急程度)
        """
        score = 0
        trigger_reasons = []
        urgency_level = 'LOW'
        
        # 1. 关键词检测
        keyword_result = self.check_keywords(message)
        if keyword_result['triggered']:
            score += keyword_result['score']
            trigger_reasons.extend(keyword_result['reasons'])
            if keyword_result['urgent']:
                urgency_level = 'HIGH'
        
        # 2. 情感分析
        emotion_result = self.analyze_emotion(message, user_history)
        if emotion_result['triggered']:
            score += emotion_result['score']
            trigger_reasons.append(f"负面情感({emotion_result['score']})")
            if emotion_result['score'] < 0.1:
                urgency_level = 'CRITICAL'
        
        # 3. 重复检测
        repeat_result = self.check_repetition(message, user_history)
        if repeat_result['triggered']:
            score += repeat_result['score']
            trigger_reasons.append(f"重复询问({repeat_result['count']}次)")
        
        # 4. 上下文分析
        context_result = self.analyze_context(user_history, group_context)
        if context_result['triggered']:
            score += context_result['score']
            trigger_reasons.extend(context_result['reasons'])
        
        # 判断是否触发
        should_trigger = score >= 3
        
        # 调整紧急程度
        if score >= 5:
            urgency_level = 'CRITICAL'
        elif score >= 4:
            urgency_level = 'HIGH'
        elif score >= 3:
            urgency_level = 'MEDIUM'
        
        return should_trigger, trigger_reasons, urgency_level
    
    def check_keywords(self, message):
        """检查关键词触发"""
        result = {
            'triggered': False,
            'score': 0,
            'reasons': [],
            'urgent': False
        }
        
        # 检查紧急关键词
        for keyword in self.urgent_keywords:
            if keyword in message:
                result['triggered'] = True
                result['score'] = 3
                result['reasons'].append(f"紧急关键词: {keyword}")
                result['urgent'] = True
                return result
        
        # 检查服务类关键词
        for keyword in self.service_keywords:
            if keyword in message:
                result['triggered'] = True
                result['score'] = 2
                result['reasons'].append(f"服务关键词: {keyword}")
        
        # 检查负面关键词
        for keyword in self.negative_keywords:
            if keyword in message:
                result['triggered'] = True
                result['score'] += 1
                result['reasons'].append(f"负面关键词: {keyword}")
        
        return result
    
    def analyze_emotion(self, message, user_history):
        """分析情感"""
        # 这里应该调用实际的情感分析API
        # 暂时使用简单的关键词匹配
        emotion_score = self.simple_emotion_analysis(message)
        
        # 分析历史情感趋势
        recent_emotions = [msg.get('emotion_score', 0.5) for msg in user_history[-5:]]
        avg_emotion = sum(recent_emotions) / len(recent_emotions) if recent_emotions else 0.5
        
        result = {
            'triggered': False,
            'score': 0
        }
        
        # 当前消息强负面
        if emotion_score < 0.1:
            result['triggered'] = True
            result['score'] = 3
        # 当前消息负面且历史平均也负面
        elif emotion_score < 0.3 and avg_emotion < 0.4:
            result['triggered'] = True
            result['score'] = 2
        # 情感急剧下降
        elif len(recent_emotions) > 0 and recent_emotions[-1] - emotion_score > 0.4:
            result['triggered'] = True
            result['score'] = 1
        
        return result
    
    def check_repetition(self, message, user_history):
        """检查重复询问"""
        result = {
            'triggered': False,
            'score': 0,
            'count': 0
        }
        
        # 检查最近10条消息中的重复
        recent_messages = [msg.get('content', '') for msg in user_history[-10:]]
        
        similarity_count = 0
        for hist_msg in recent_messages:
            if self.calculate_similarity(message, hist_msg) > 0.8:
                similarity_count += 1
        
        result['count'] = similarity_count
        
        if similarity_count >= 3:
            result['triggered'] = True
            result['score'] = 2
        elif similarity_count >= 2:
            result['triggered'] = True
            result['score'] = 1
        
        return result
    
    def simple_emotion_analysis(self, message):
        """简单的情感分析"""
        positive_words = ['好', '谢谢', '满意', '不错', '棒']
        negative_words = ['不好', '差', '烂', '垃圾', '不满意', '气', '怒']
        
        positive_count = sum(1 for word in positive_words if word in message)
        negative_count = sum(1 for word in negative_words if word in message)
        
        # 简单的评分逻辑
        if negative_count > positive_count:
            return max(0.1, 0.5 - negative_count * 0.2)
        elif positive_count > negative_count:
            return min(0.9, 0.5 + positive_count * 0.2)
        else:
            return 0.5
    
    def calculate_similarity(self, text1, text2):
        """计算文本相似度"""
        # 简单的字符级相似度计算
        if not text1 or not text2:
            return 0.0
        
        # 移除标点符号和空格
        import re
        text1_clean = re.sub(r'[^\w]', '', text1)
        text2_clean = re.sub(r'[^\w]', '', text2)
        
        if text1_clean == text2_clean:
            return 1.0
        
        # 计算编辑距离
        def edit_distance(s1, s2):
            m, n = len(s1), len(s2)
            dp = [[0] * (n + 1) for _ in range(m + 1)]
            
            for i in range(m + 1):
                dp[i][0] = i
            for j in range(n + 1):
                dp[0][j] = j
            
            for i in range(1, m + 1):
                for j in range(1, n + 1):
                    if s1[i-1] == s2[j-1]:
                        dp[i][j] = dp[i-1][j-1]
                    else:
                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
            
            return dp[m][n]
        
        distance = edit_distance(text1_clean, text2_clean)
        max_len = max(len(text1_clean), len(text2_clean))
        
        return 1.0 - (distance / max_len) if max_len > 0 else 0.0
```

### 4.3 通知推送系统

#### 4.3.1 推送服务接口
```python
class NotificationService:
    def __init__(self):
        self.push_providers = {
            'app': AppPushProvider(),
            'wechat': WeChatPushProvider(),
            'sms': SMSPushProvider(),
            'email': EmailPushProvider()
        }
    
    def send_notification(self, level, content, recipients, channels=None):
        """
        发送通知
        
        Args:
            level: 通知级别 (LOW, MEDIUM, HIGH, CRITICAL)
            content: 通知内容
            recipients: 接收人列表
            channels: 推送渠道列表
        """
        if channels is None:
            channels = self.get_default_channels(level)
        
        for channel in channels:
            if channel in self.push_providers:
                try:
                    self.push_providers[channel].send(content, recipients)
                except Exception as e:
                    print(f"推送失败 - 渠道: {channel}, 错误: {e}")
    
    def get_default_channels(self, level):
        """根据级别获取默认推送渠道"""
        channel_map = {
            'LOW': ['app'],
            'MEDIUM': ['app', 'wechat'],
            'HIGH': ['app', 'wechat', 'sms'],
            'CRITICAL': ['app', 'wechat', 'sms', 'email']
        }
        return channel_map.get(level, ['app'])
```

## 5. 用户体验优化

### 5.1 平滑过渡设计

#### 5.1.1 转接话术模板
```python
TRANSFER_TEMPLATES = {
    'normal': [
        "我来为您安排专业客服，请稍等片刻~",
        "正在为您转接人工客服，请耐心等待",
        "让我为您联系专业的客服人员"
    ],
    'urgent': [
        "您的问题我们非常重视，正在为您联系负责人",
        "马上为您安排专人处理，请稍候",
        "您的情况比较特殊，正在联系专业人员"
    ],
    'complaint': [
        "非常抱歉给您带来不便，主管正在为您处理",
        "我们对此非常重视，正在联系相关负责人",
        "您的意见我们会认真对待，请稍等"
    ]
}

WAITING_TEMPLATES = [
    "客服正在赶来的路上，预计1-2分钟",
    "您是第1位等待的用户，很快就轮到您了",
    "如有紧急情况，可直接拨打客服热线：400-xxx-xxxx",
    "感谢您的耐心等待，我们会尽快为您处理"
]
```

#### 5.1.2 状态提示设计
```python
STATUS_MESSAGES = {
    'transferring': "正在为您转接人工客服...",
    'waiting': "已为您安排专人处理，请稍候",
    'connected': "人工客服已接入，为您服务",
    'resolved': "问题已为您解决，感谢您的耐心",
    'feedback': "请为本次服务打分：😊😐😞"
}
```

### 5.2 反馈机制

#### 5.2.1 处理完成反馈
```python
COMPLETION_TEMPLATES = {
    'satisfied': [
        "问题已为您解决，如还有疑问请随时联系",
        "很高兴能为您解决问题，祝您生活愉快",
        "感谢您的信任，我们会继续努力提供更好的服务"
    ],
    'feedback_request': [
        "请为本次服务打分：😊😐😞",
        "您的建议对我们很重要，期待您的反馈",
        "如果满意请给个好评，不满意请告诉我们改进方向"
    ]
}
```

#### 5.2.2 自动回复恢复提示
```python
RECOVERY_TEMPLATES = [
    "智能助手已重新上线，继续为您服务",
    "自动回复已恢复，如需人工服务随时呼叫",
    "机器人重新待命，有问题随时找我"
]
```

## 6. 监控和统计

### 6.1 关键指标

#### 6.1.1 触发相关指标
- **触发率**：人工接管触发次数 / 总消息数
- **准确率**：正确触发次数 / 总触发次数
- **响应时间**：从触发到人工接入的平均时间
- **解决时间**：从接入到问题解决的平均时间

#### 6.1.2 用户满意度指标
- **转接满意度**：用户对转接过程的满意度评分
- **处理满意度**：用户对问题处理结果的满意度评分
- **重复触发率**：同一用户重复触发人工接管的比例

### 6.2 数据分析

#### 6.2.1 触发原因分析
```sql
-- 触发原因统计
SELECT 
    trigger_type,
    COUNT(*) as count,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM manual_takeover_log) as percentage
FROM manual_takeover_log 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY trigger_type
ORDER BY count DESC;
```

#### 6.2.2 处理效率分析
```sql
-- 处理时间分析
SELECT 
    urgency_level,
    AVG(TIMESTAMPDIFF(MINUTE, created_at, resolved_at)) as avg_resolution_time,
    MIN(TIMESTAMPDIFF(MINUTE, created_at, resolved_at)) as min_resolution_time,
    MAX(TIMESTAMPDIFF(MINUTE, created_at, resolved_at)) as max_resolution_time
FROM manual_takeover_log 
WHERE status = 'RESOLVED' 
    AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY urgency_level;
```

## 7. 实施计划

### 7.1 第一阶段：基础功能开发（2周）
- 数据库表结构设计和创建
- 核心触发算法开发
- 基础通知推送功能
- 简单的管理界面

### 7.2 第二阶段：功能完善（2周）
- 情感分析模块集成
- 高级触发条件实现
- 多渠道推送系统
- 用户体验优化

### 7.3 第三阶段：测试和优化（1周）
- 全面功能测试
- 性能优化
- 用户反馈收集和改进
- 上线部署

## 8. 风险评估和应对

### 8.1 技术风险
- **误触发风险**：建立白名单机制，持续优化算法
- **性能风险**：实施缓存策略，异步处理
- **可用性风险**：建立降级机制，确保基础功能可用

### 8.2 业务风险
- **用户体验风险**：充分测试，渐进式上线
- **运营成本风险**：合理设置触发阈值，避免过度触发
- **服务质量风险**：建立培训机制，提升人工服务质量

## 9. 总结

本人工接管机制设计方案通过多维度的触发条件检测、分级的预警处理机制和完善的用户体验设计，确保了在自动回复无法满足用户需求时能够及时、准确地转接人工服务。该方案具有以下特点：

1. **智能化**：基于关键词、情感分析和重复检测的多维度触发机制
2. **及时性**：分级推送和超时处理确保快速响应
3. **准确性**：通过算法优化和历史数据分析提高触发准确率
4. **用户友好**：平滑的转接过程和贴心的等待提示
5. **可监控**：完善的数据统计和分析机制
6. **可扩展**：模块化设计支持功能扩展和优化

通过实施这套人工接管机制，可以显著提升用户满意度，降低客服工作压力，提高整体服务质量。